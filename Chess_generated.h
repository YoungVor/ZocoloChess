// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHESS_SERIALIZER_H_
#define FLATBUFFERS_GENERATED_CHESS_SERIALIZER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");


namespace Serializer {

struct Coord;

struct Move;

struct ChessBoard;
struct ChessBoardBuilder;

enum Color : int8_t {
  Color_White = 0,
  Color_Black = 1,
  Color_MIN = Color_White,
  Color_MAX = Color_Black
};

inline const Color (&EnumValuesColor())[2] {
  static const Color values[] = {
    Color_White,
    Color_Black
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[3] = {
    "White",
    "Black",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (::flatbuffers::IsOutRange(e, Color_White, Color_Black)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

enum PieceType : int8_t {
  PieceType_Pawn = 0,
  PieceType_Bishop = 1,
  PieceType_Knight = 2,
  PieceType_Rook = 3,
  PieceType_Queen = 4,
  PieceType_King = 5,
  PieceType_MIN = PieceType_Pawn,
  PieceType_MAX = PieceType_King
};

inline const PieceType (&EnumValuesPieceType())[6] {
  static const PieceType values[] = {
    PieceType_Pawn,
    PieceType_Bishop,
    PieceType_Knight,
    PieceType_Rook,
    PieceType_Queen,
    PieceType_King
  };
  return values;
}

inline const char * const *EnumNamesPieceType() {
  static const char * const names[7] = {
    "Pawn",
    "Bishop",
    "Knight",
    "Rook",
    "Queen",
    "King",
    nullptr
  };
  return names;
}

inline const char *EnumNamePieceType(PieceType e) {
  if (::flatbuffers::IsOutRange(e, PieceType_Pawn, PieceType_King)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPieceType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Coord FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t column_;
  int8_t row_;

 public:
  Coord()
      : column_(0),
        row_(0) {
  }
  Coord(int8_t _column, int8_t _row)
      : column_(::flatbuffers::EndianScalar(_column)),
        row_(::flatbuffers::EndianScalar(_row)) {
  }
  int8_t column() const {
    return ::flatbuffers::EndianScalar(column_);
  }
  int8_t row() const {
    return ::flatbuffers::EndianScalar(row_);
  }
};
FLATBUFFERS_STRUCT_END(Coord, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Move FLATBUFFERS_FINAL_CLASS {
 private:
  Serializer::Coord piece_;
  Serializer::Coord dest_;

 public:
  Move()
      : piece_(),
        dest_() {
  }
  Move(const Serializer::Coord &_piece, const Serializer::Coord &_dest)
      : piece_(_piece),
        dest_(_dest) {
  }
  const Serializer::Coord &piece() const {
    return piece_;
  }
  const Serializer::Coord &dest() const {
    return dest_;
  }
};
FLATBUFFERS_STRUCT_END(Move, 4);

struct ChessBoard FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChessBoardBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_WHITE_KING_CAN_CASTLE_A = 6,
    VT_WHITE_KING_CAN_CASTLE_H = 8,
    VT_BLACK_KING_CAN_CASTLE_A = 10,
    VT_BLACK_KING_CAN_CASTLE_H = 12,
    VT_MOVE_COUNT = 14,
    VT_WHITE_PAWNS = 16,
    VT_BLACK_PAWNS = 18,
    VT_WHITE_BISHOPS = 20,
    VT_BLACK_BISHOPS = 22,
    VT_WHITE_KNIGHTS = 24,
    VT_BLACK_KNIGHTS = 26,
    VT_WHITE_ROOKS = 28,
    VT_BLACK_ROOKS = 30,
    VT_WHITE_QUEENS = 32,
    VT_BLACK_QUEENS = 34,
    VT_WHITE_KINGS = 36,
    VT_BLACK_KINGS = 38,
    VT_MOVES = 40
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool white_king_can_castle_a() const {
    return GetField<uint8_t>(VT_WHITE_KING_CAN_CASTLE_A, 0) != 0;
  }
  bool white_king_can_castle_h() const {
    return GetField<uint8_t>(VT_WHITE_KING_CAN_CASTLE_H, 0) != 0;
  }
  bool black_king_can_castle_a() const {
    return GetField<uint8_t>(VT_BLACK_KING_CAN_CASTLE_A, 0) != 0;
  }
  bool black_king_can_castle_h() const {
    return GetField<uint8_t>(VT_BLACK_KING_CAN_CASTLE_H, 0) != 0;
  }
  int16_t move_count() const {
    return GetField<int16_t>(VT_MOVE_COUNT, 0);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_pawns() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_PAWNS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_pawns() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_PAWNS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_bishops() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_BISHOPS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_bishops() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_BISHOPS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_knights() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_KNIGHTS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_knights() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_KNIGHTS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_rooks() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_ROOKS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_rooks() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_ROOKS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_queens() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_QUEENS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_queens() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_QUEENS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_kings() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_KINGS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_kings() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_KINGS);
  }
  const ::flatbuffers::Vector<const Serializer::Move *> *moves() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Move *> *>(VT_MOVES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_WHITE_KING_CAN_CASTLE_A, 1) &&
           VerifyField<uint8_t>(verifier, VT_WHITE_KING_CAN_CASTLE_H, 1) &&
           VerifyField<uint8_t>(verifier, VT_BLACK_KING_CAN_CASTLE_A, 1) &&
           VerifyField<uint8_t>(verifier, VT_BLACK_KING_CAN_CASTLE_H, 1) &&
           VerifyField<int16_t>(verifier, VT_MOVE_COUNT, 2) &&
           VerifyOffset(verifier, VT_WHITE_PAWNS) &&
           verifier.VerifyVector(white_pawns()) &&
           VerifyOffset(verifier, VT_BLACK_PAWNS) &&
           verifier.VerifyVector(black_pawns()) &&
           VerifyOffset(verifier, VT_WHITE_BISHOPS) &&
           verifier.VerifyVector(white_bishops()) &&
           VerifyOffset(verifier, VT_BLACK_BISHOPS) &&
           verifier.VerifyVector(black_bishops()) &&
           VerifyOffset(verifier, VT_WHITE_KNIGHTS) &&
           verifier.VerifyVector(white_knights()) &&
           VerifyOffset(verifier, VT_BLACK_KNIGHTS) &&
           verifier.VerifyVector(black_knights()) &&
           VerifyOffset(verifier, VT_WHITE_ROOKS) &&
           verifier.VerifyVector(white_rooks()) &&
           VerifyOffset(verifier, VT_BLACK_ROOKS) &&
           verifier.VerifyVector(black_rooks()) &&
           VerifyOffset(verifier, VT_WHITE_QUEENS) &&
           verifier.VerifyVector(white_queens()) &&
           VerifyOffset(verifier, VT_BLACK_QUEENS) &&
           verifier.VerifyVector(black_queens()) &&
           VerifyOffset(verifier, VT_WHITE_KINGS) &&
           verifier.VerifyVector(white_kings()) &&
           VerifyOffset(verifier, VT_BLACK_KINGS) &&
           verifier.VerifyVector(black_kings()) &&
           VerifyOffset(verifier, VT_MOVES) &&
           verifier.VerifyVector(moves()) &&
           verifier.EndTable();
  }
};

struct ChessBoardBuilder {
  typedef ChessBoard Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ChessBoard::VT_ID, id);
  }
  void add_white_king_can_castle_a(bool white_king_can_castle_a) {
    fbb_.AddElement<uint8_t>(ChessBoard::VT_WHITE_KING_CAN_CASTLE_A, static_cast<uint8_t>(white_king_can_castle_a), 0);
  }
  void add_white_king_can_castle_h(bool white_king_can_castle_h) {
    fbb_.AddElement<uint8_t>(ChessBoard::VT_WHITE_KING_CAN_CASTLE_H, static_cast<uint8_t>(white_king_can_castle_h), 0);
  }
  void add_black_king_can_castle_a(bool black_king_can_castle_a) {
    fbb_.AddElement<uint8_t>(ChessBoard::VT_BLACK_KING_CAN_CASTLE_A, static_cast<uint8_t>(black_king_can_castle_a), 0);
  }
  void add_black_king_can_castle_h(bool black_king_can_castle_h) {
    fbb_.AddElement<uint8_t>(ChessBoard::VT_BLACK_KING_CAN_CASTLE_H, static_cast<uint8_t>(black_king_can_castle_h), 0);
  }
  void add_move_count(int16_t move_count) {
    fbb_.AddElement<int16_t>(ChessBoard::VT_MOVE_COUNT, move_count, 0);
  }
  void add_white_pawns(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_pawns) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_PAWNS, white_pawns);
  }
  void add_black_pawns(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_pawns) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_PAWNS, black_pawns);
  }
  void add_white_bishops(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_bishops) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_BISHOPS, white_bishops);
  }
  void add_black_bishops(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_bishops) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_BISHOPS, black_bishops);
  }
  void add_white_knights(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_knights) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_KNIGHTS, white_knights);
  }
  void add_black_knights(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_knights) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_KNIGHTS, black_knights);
  }
  void add_white_rooks(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_rooks) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_ROOKS, white_rooks);
  }
  void add_black_rooks(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_rooks) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_ROOKS, black_rooks);
  }
  void add_white_queens(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_queens) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_QUEENS, white_queens);
  }
  void add_black_queens(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_queens) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_QUEENS, black_queens);
  }
  void add_white_kings(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_kings) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_KINGS, white_kings);
  }
  void add_black_kings(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_kings) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_KINGS, black_kings);
  }
  void add_moves(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Move *>> moves) {
    fbb_.AddOffset(ChessBoard::VT_MOVES, moves);
  }
  explicit ChessBoardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChessBoard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChessBoard>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChessBoard> CreateChessBoard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    bool white_king_can_castle_a = false,
    bool white_king_can_castle_h = false,
    bool black_king_can_castle_a = false,
    bool black_king_can_castle_h = false,
    int16_t move_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_pawns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_pawns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_bishops = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_bishops = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_knights = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_knights = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_rooks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_rooks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_queens = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_queens = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_kings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_kings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Move *>> moves = 0) {
  ChessBoardBuilder builder_(_fbb);
  builder_.add_moves(moves);
  builder_.add_black_kings(black_kings);
  builder_.add_white_kings(white_kings);
  builder_.add_black_queens(black_queens);
  builder_.add_white_queens(white_queens);
  builder_.add_black_rooks(black_rooks);
  builder_.add_white_rooks(white_rooks);
  builder_.add_black_knights(black_knights);
  builder_.add_white_knights(white_knights);
  builder_.add_black_bishops(black_bishops);
  builder_.add_white_bishops(white_bishops);
  builder_.add_black_pawns(black_pawns);
  builder_.add_white_pawns(white_pawns);
  builder_.add_id(id);
  builder_.add_move_count(move_count);
  builder_.add_black_king_can_castle_h(black_king_can_castle_h);
  builder_.add_black_king_can_castle_a(black_king_can_castle_a);
  builder_.add_white_king_can_castle_h(white_king_can_castle_h);
  builder_.add_white_king_can_castle_a(white_king_can_castle_a);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChessBoard> CreateChessBoardDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    bool white_king_can_castle_a = false,
    bool white_king_can_castle_h = false,
    bool black_king_can_castle_a = false,
    bool black_king_can_castle_h = false,
    int16_t move_count = 0,
    const std::vector<Serializer::Coord> *white_pawns = nullptr,
    const std::vector<Serializer::Coord> *black_pawns = nullptr,
    const std::vector<Serializer::Coord> *white_bishops = nullptr,
    const std::vector<Serializer::Coord> *black_bishops = nullptr,
    const std::vector<Serializer::Coord> *white_knights = nullptr,
    const std::vector<Serializer::Coord> *black_knights = nullptr,
    const std::vector<Serializer::Coord> *white_rooks = nullptr,
    const std::vector<Serializer::Coord> *black_rooks = nullptr,
    const std::vector<Serializer::Coord> *white_queens = nullptr,
    const std::vector<Serializer::Coord> *black_queens = nullptr,
    const std::vector<Serializer::Coord> *white_kings = nullptr,
    const std::vector<Serializer::Coord> *black_kings = nullptr,
    const std::vector<Serializer::Move> *moves = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto white_pawns__ = white_pawns ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_pawns) : 0;
  auto black_pawns__ = black_pawns ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_pawns) : 0;
  auto white_bishops__ = white_bishops ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_bishops) : 0;
  auto black_bishops__ = black_bishops ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_bishops) : 0;
  auto white_knights__ = white_knights ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_knights) : 0;
  auto black_knights__ = black_knights ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_knights) : 0;
  auto white_rooks__ = white_rooks ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_rooks) : 0;
  auto black_rooks__ = black_rooks ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_rooks) : 0;
  auto white_queens__ = white_queens ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_queens) : 0;
  auto black_queens__ = black_queens ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_queens) : 0;
  auto white_kings__ = white_kings ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_kings) : 0;
  auto black_kings__ = black_kings ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_kings) : 0;
  auto moves__ = moves ? _fbb.CreateVectorOfStructs<Serializer::Move>(*moves) : 0;
  return Serializer::CreateChessBoard(
      _fbb,
      id__,
      white_king_can_castle_a,
      white_king_can_castle_h,
      black_king_can_castle_a,
      black_king_can_castle_h,
      move_count,
      white_pawns__,
      black_pawns__,
      white_bishops__,
      black_bishops__,
      white_knights__,
      black_knights__,
      white_rooks__,
      black_rooks__,
      white_queens__,
      black_queens__,
      white_kings__,
      black_kings__,
      moves__);
}

inline const Serializer::ChessBoard *GetChessBoard(const void *buf) {
  return ::flatbuffers::GetRoot<Serializer::ChessBoard>(buf);
}

inline const Serializer::ChessBoard *GetSizePrefixedChessBoard(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Serializer::ChessBoard>(buf);
}

inline bool VerifyChessBoardBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Serializer::ChessBoard>(nullptr);
}

inline bool VerifySizePrefixedChessBoardBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Serializer::ChessBoard>(nullptr);
}

inline void FinishChessBoardBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Serializer::ChessBoard> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedChessBoardBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Serializer::ChessBoard> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Serializer

#endif  // FLATBUFFERS_GENERATED_CHESS_SERIALIZER_H_
