// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHESS_SERIALIZER_H_
#define FLATBUFFERS_GENERATED_CHESS_SERIALIZER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "ChessGame.h"

namespace Serializer {

struct Coord;

struct Move;

struct ChessBoard;
struct ChessBoardBuilder;
struct ChessBoardT;

enum Color : int8_t {
  Color_White = 0,
  Color_Black = 1,
  Color_MIN = Color_White,
  Color_MAX = Color_Black
};

inline const Color (&EnumValuesColor())[2] {
  static const Color values[] = {
    Color_White,
    Color_Black
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[3] = {
    "White",
    "Black",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (::flatbuffers::IsOutRange(e, Color_White, Color_Black)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

enum PieceType : int8_t {
  PieceType_Pawn = 0,
  PieceType_Bishop = 1,
  PieceType_Knight = 2,
  PieceType_Rook = 3,
  PieceType_Queen = 4,
  PieceType_King = 5,
  PieceType_MIN = PieceType_Pawn,
  PieceType_MAX = PieceType_King
};

inline const PieceType (&EnumValuesPieceType())[6] {
  static const PieceType values[] = {
    PieceType_Pawn,
    PieceType_Bishop,
    PieceType_Knight,
    PieceType_Rook,
    PieceType_Queen,
    PieceType_King
  };
  return values;
}

inline const char * const *EnumNamesPieceType() {
  static const char * const names[7] = {
    "Pawn",
    "Bishop",
    "Knight",
    "Rook",
    "Queen",
    "King",
    nullptr
  };
  return names;
}

inline const char *EnumNamePieceType(PieceType e) {
  if (::flatbuffers::IsOutRange(e, PieceType_Pawn, PieceType_King)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPieceType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Coord FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t column_;
  int8_t row_;

 public:
  Coord()
      : column_(0),
        row_(0) {
  }
  Coord(int8_t _column, int8_t _row)
      : column_(::flatbuffers::EndianScalar(_column)),
        row_(::flatbuffers::EndianScalar(_row)) {
  }
  int8_t column() const {
    return ::flatbuffers::EndianScalar(column_);
  }
  void mutate_column(int8_t _column) {
    ::flatbuffers::WriteScalar(&column_, _column);
  }
  int8_t row() const {
    return ::flatbuffers::EndianScalar(row_);
  }
  void mutate_row(int8_t _row) {
    ::flatbuffers::WriteScalar(&row_, _row);
  }
};
FLATBUFFERS_STRUCT_END(Coord, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Move FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t type_;
  Serializer::Coord move_;

 public:
  Move()
      : type_(0),
        move_() {
  }
  Move(Serializer::PieceType _type, const Serializer::Coord &_move)
      : type_(::flatbuffers::EndianScalar(static_cast<int8_t>(_type))),
        move_(_move) {
  }
  Serializer::PieceType type() const {
    return static_cast<Serializer::PieceType>(::flatbuffers::EndianScalar(type_));
  }
  void mutate_type(Serializer::PieceType _type) {
    ::flatbuffers::WriteScalar(&type_, static_cast<int8_t>(_type));
  }
  const Serializer::Coord &move() const {
    return move_;
  }
  Serializer::Coord &mutable_move() {
    return move_;
  }
};
FLATBUFFERS_STRUCT_END(Move, 3);

struct ChessBoardT : public ::flatbuffers::NativeTable {
  typedef ChessBoard TableType;
  std::vector<ZocoloChess::coordinate> white_pawns{};
  std::vector<ZocoloChess::coordinate> black_pawns{};
  std::vector<ZocoloChess::coordinate> white_bishops{};
  std::vector<ZocoloChess::coordinate> black_bishops{};
  std::vector<ZocoloChess::coordinate> white_knights{};
  std::vector<ZocoloChess::coordinate> black_knights{};
  std::vector<ZocoloChess::coordinate> white_rooks{};
  std::vector<ZocoloChess::coordinate> black_rooks{};
  std::vector<ZocoloChess::coordinate> white_queens{};
  std::vector<ZocoloChess::coordinate> black_queens{};
  std::vector<ZocoloChess::coordinate> white_kings{};
  std::vector<ZocoloChess::coordinate> black_kings{};
  std::vector<Serializer::Move> moves{};
};

struct ChessBoard FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChessBoardT NativeTableType;
  typedef ChessBoardBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHITE_PAWNS = 4,
    VT_BLACK_PAWNS = 6,
    VT_WHITE_BISHOPS = 8,
    VT_BLACK_BISHOPS = 10,
    VT_WHITE_KNIGHTS = 12,
    VT_BLACK_KNIGHTS = 14,
    VT_WHITE_ROOKS = 16,
    VT_BLACK_ROOKS = 18,
    VT_WHITE_QUEENS = 20,
    VT_BLACK_QUEENS = 22,
    VT_WHITE_KINGS = 24,
    VT_BLACK_KINGS = 26,
    VT_MOVES = 28
  };
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_pawns() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_PAWNS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_white_pawns() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_PAWNS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_pawns() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_PAWNS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_black_pawns() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_PAWNS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_bishops() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_BISHOPS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_white_bishops() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_BISHOPS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_bishops() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_BISHOPS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_black_bishops() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_BISHOPS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_knights() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_KNIGHTS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_white_knights() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_KNIGHTS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_knights() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_KNIGHTS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_black_knights() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_KNIGHTS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_rooks() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_ROOKS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_white_rooks() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_ROOKS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_rooks() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_ROOKS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_black_rooks() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_ROOKS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_queens() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_QUEENS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_white_queens() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_QUEENS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_queens() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_QUEENS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_black_queens() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_QUEENS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *white_kings() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_KINGS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_white_kings() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_WHITE_KINGS);
  }
  const ::flatbuffers::Vector<const Serializer::Coord *> *black_kings() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_KINGS);
  }
  ::flatbuffers::Vector<const Serializer::Coord *> *mutable_black_kings() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Coord *> *>(VT_BLACK_KINGS);
  }
  const ::flatbuffers::Vector<const Serializer::Move *> *moves() const {
    return GetPointer<const ::flatbuffers::Vector<const Serializer::Move *> *>(VT_MOVES);
  }
  ::flatbuffers::Vector<const Serializer::Move *> *mutable_moves() {
    return GetPointer<::flatbuffers::Vector<const Serializer::Move *> *>(VT_MOVES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WHITE_PAWNS) &&
           verifier.VerifyVector(white_pawns()) &&
           VerifyOffset(verifier, VT_BLACK_PAWNS) &&
           verifier.VerifyVector(black_pawns()) &&
           VerifyOffset(verifier, VT_WHITE_BISHOPS) &&
           verifier.VerifyVector(white_bishops()) &&
           VerifyOffset(verifier, VT_BLACK_BISHOPS) &&
           verifier.VerifyVector(black_bishops()) &&
           VerifyOffset(verifier, VT_WHITE_KNIGHTS) &&
           verifier.VerifyVector(white_knights()) &&
           VerifyOffset(verifier, VT_BLACK_KNIGHTS) &&
           verifier.VerifyVector(black_knights()) &&
           VerifyOffset(verifier, VT_WHITE_ROOKS) &&
           verifier.VerifyVector(white_rooks()) &&
           VerifyOffset(verifier, VT_BLACK_ROOKS) &&
           verifier.VerifyVector(black_rooks()) &&
           VerifyOffset(verifier, VT_WHITE_QUEENS) &&
           verifier.VerifyVector(white_queens()) &&
           VerifyOffset(verifier, VT_BLACK_QUEENS) &&
           verifier.VerifyVector(black_queens()) &&
           VerifyOffset(verifier, VT_WHITE_KINGS) &&
           verifier.VerifyVector(white_kings()) &&
           VerifyOffset(verifier, VT_BLACK_KINGS) &&
           verifier.VerifyVector(black_kings()) &&
           VerifyOffset(verifier, VT_MOVES) &&
           verifier.VerifyVector(moves()) &&
           verifier.EndTable();
  }
  ChessBoardT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChessBoardT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChessBoard> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChessBoardT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChessBoardBuilder {
  typedef ChessBoard Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_white_pawns(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_pawns) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_PAWNS, white_pawns);
  }
  void add_black_pawns(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_pawns) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_PAWNS, black_pawns);
  }
  void add_white_bishops(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_bishops) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_BISHOPS, white_bishops);
  }
  void add_black_bishops(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_bishops) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_BISHOPS, black_bishops);
  }
  void add_white_knights(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_knights) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_KNIGHTS, white_knights);
  }
  void add_black_knights(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_knights) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_KNIGHTS, black_knights);
  }
  void add_white_rooks(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_rooks) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_ROOKS, white_rooks);
  }
  void add_black_rooks(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_rooks) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_ROOKS, black_rooks);
  }
  void add_white_queens(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_queens) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_QUEENS, white_queens);
  }
  void add_black_queens(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_queens) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_QUEENS, black_queens);
  }
  void add_white_kings(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_kings) {
    fbb_.AddOffset(ChessBoard::VT_WHITE_KINGS, white_kings);
  }
  void add_black_kings(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_kings) {
    fbb_.AddOffset(ChessBoard::VT_BLACK_KINGS, black_kings);
  }
  void add_moves(::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Move *>> moves) {
    fbb_.AddOffset(ChessBoard::VT_MOVES, moves);
  }
  explicit ChessBoardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChessBoard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChessBoard>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChessBoard> CreateChessBoard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_pawns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_pawns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_bishops = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_bishops = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_knights = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_knights = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_rooks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_rooks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_queens = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_queens = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> white_kings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Coord *>> black_kings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Serializer::Move *>> moves = 0) {
  ChessBoardBuilder builder_(_fbb);
  builder_.add_moves(moves);
  builder_.add_black_kings(black_kings);
  builder_.add_white_kings(white_kings);
  builder_.add_black_queens(black_queens);
  builder_.add_white_queens(white_queens);
  builder_.add_black_rooks(black_rooks);
  builder_.add_white_rooks(white_rooks);
  builder_.add_black_knights(black_knights);
  builder_.add_white_knights(white_knights);
  builder_.add_black_bishops(black_bishops);
  builder_.add_white_bishops(white_bishops);
  builder_.add_black_pawns(black_pawns);
  builder_.add_white_pawns(white_pawns);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChessBoard> CreateChessBoardDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Serializer::Coord> *white_pawns = nullptr,
    const std::vector<Serializer::Coord> *black_pawns = nullptr,
    const std::vector<Serializer::Coord> *white_bishops = nullptr,
    const std::vector<Serializer::Coord> *black_bishops = nullptr,
    const std::vector<Serializer::Coord> *white_knights = nullptr,
    const std::vector<Serializer::Coord> *black_knights = nullptr,
    const std::vector<Serializer::Coord> *white_rooks = nullptr,
    const std::vector<Serializer::Coord> *black_rooks = nullptr,
    const std::vector<Serializer::Coord> *white_queens = nullptr,
    const std::vector<Serializer::Coord> *black_queens = nullptr,
    const std::vector<Serializer::Coord> *white_kings = nullptr,
    const std::vector<Serializer::Coord> *black_kings = nullptr,
    const std::vector<Serializer::Move> *moves = nullptr) {
  auto white_pawns__ = white_pawns ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_pawns) : 0;
  auto black_pawns__ = black_pawns ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_pawns) : 0;
  auto white_bishops__ = white_bishops ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_bishops) : 0;
  auto black_bishops__ = black_bishops ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_bishops) : 0;
  auto white_knights__ = white_knights ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_knights) : 0;
  auto black_knights__ = black_knights ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_knights) : 0;
  auto white_rooks__ = white_rooks ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_rooks) : 0;
  auto black_rooks__ = black_rooks ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_rooks) : 0;
  auto white_queens__ = white_queens ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_queens) : 0;
  auto black_queens__ = black_queens ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_queens) : 0;
  auto white_kings__ = white_kings ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*white_kings) : 0;
  auto black_kings__ = black_kings ? _fbb.CreateVectorOfStructs<Serializer::Coord>(*black_kings) : 0;
  auto moves__ = moves ? _fbb.CreateVectorOfStructs<Serializer::Move>(*moves) : 0;
  return Serializer::CreateChessBoard(
      _fbb,
      white_pawns__,
      black_pawns__,
      white_bishops__,
      black_bishops__,
      white_knights__,
      black_knights__,
      white_rooks__,
      black_rooks__,
      white_queens__,
      black_queens__,
      white_kings__,
      black_kings__,
      moves__);
}

::flatbuffers::Offset<ChessBoard> CreateChessBoard(::flatbuffers::FlatBufferBuilder &_fbb, const ChessBoardT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ChessBoardT *ChessBoard::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ChessBoardT>(new ChessBoardT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChessBoard::UnPackTo(ChessBoardT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = white_pawns(); if (_e) { _o->white_pawns.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->white_pawns[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->white_pawns.resize(0); } }
  { auto _e = black_pawns(); if (_e) { _o->black_pawns.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->black_pawns[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->black_pawns.resize(0); } }
  { auto _e = white_bishops(); if (_e) { _o->white_bishops.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->white_bishops[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->white_bishops.resize(0); } }
  { auto _e = black_bishops(); if (_e) { _o->black_bishops.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->black_bishops[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->black_bishops.resize(0); } }
  { auto _e = white_knights(); if (_e) { _o->white_knights.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->white_knights[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->white_knights.resize(0); } }
  { auto _e = black_knights(); if (_e) { _o->black_knights.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->black_knights[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->black_knights.resize(0); } }
  { auto _e = white_rooks(); if (_e) { _o->white_rooks.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->white_rooks[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->white_rooks.resize(0); } }
  { auto _e = black_rooks(); if (_e) { _o->black_rooks.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->black_rooks[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->black_rooks.resize(0); } }
  { auto _e = white_queens(); if (_e) { _o->white_queens.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->white_queens[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->white_queens.resize(0); } }
  { auto _e = black_queens(); if (_e) { _o->black_queens.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->black_queens[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->black_queens.resize(0); } }
  { auto _e = white_kings(); if (_e) { _o->white_kings.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->white_kings[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->white_kings.resize(0); } }
  { auto _e = black_kings(); if (_e) { _o->black_kings.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->black_kings[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->black_kings.resize(0); } }
  { auto _e = moves(); if (_e) { _o->moves.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->moves[_i] = *_e->Get(_i); } } else { _o->moves.resize(0); } }
}

inline ::flatbuffers::Offset<ChessBoard> ChessBoard::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChessBoardT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChessBoard(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChessBoard> CreateChessBoard(::flatbuffers::FlatBufferBuilder &_fbb, const ChessBoardT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChessBoardT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _white_pawns = _o->white_pawns.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->white_pawns) : 0;
  auto _black_pawns = _o->black_pawns.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->black_pawns) : 0;
  auto _white_bishops = _o->white_bishops.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->white_bishops) : 0;
  auto _black_bishops = _o->black_bishops.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->black_bishops) : 0;
  auto _white_knights = _o->white_knights.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->white_knights) : 0;
  auto _black_knights = _o->black_knights.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->black_knights) : 0;
  auto _white_rooks = _o->white_rooks.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->white_rooks) : 0;
  auto _black_rooks = _o->black_rooks.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->black_rooks) : 0;
  auto _white_queens = _o->white_queens.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->white_queens) : 0;
  auto _black_queens = _o->black_queens.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->black_queens) : 0;
  auto _white_kings = _o->white_kings.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->white_kings) : 0;
  auto _black_kings = _o->black_kings.size() ? _fbb.CreateVectorOfNativeStructs<Serializer::Coord, ZocoloChess::coordinate>(_o->black_kings) : 0;
  auto _moves = _o->moves.size() ? _fbb.CreateVectorOfStructs(_o->moves) : 0;
  return Serializer::CreateChessBoard(
      _fbb,
      _white_pawns,
      _black_pawns,
      _white_bishops,
      _black_bishops,
      _white_knights,
      _black_knights,
      _white_rooks,
      _black_rooks,
      _white_queens,
      _black_queens,
      _white_kings,
      _black_kings,
      _moves);
}

inline const Serializer::ChessBoard *GetChessBoard(const void *buf) {
  return ::flatbuffers::GetRoot<Serializer::ChessBoard>(buf);
}

inline const Serializer::ChessBoard *GetSizePrefixedChessBoard(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Serializer::ChessBoard>(buf);
}

inline ChessBoard *GetMutableChessBoard(void *buf) {
  return ::flatbuffers::GetMutableRoot<ChessBoard>(buf);
}

inline Serializer::ChessBoard *GetMutableSizePrefixedChessBoard(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Serializer::ChessBoard>(buf);
}

inline bool VerifyChessBoardBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Serializer::ChessBoard>(nullptr);
}

inline bool VerifySizePrefixedChessBoardBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Serializer::ChessBoard>(nullptr);
}

inline void FinishChessBoardBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Serializer::ChessBoard> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedChessBoardBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Serializer::ChessBoard> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Serializer::ChessBoardT> UnPackChessBoard(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Serializer::ChessBoardT>(GetChessBoard(buf)->UnPack(res));
}

inline std::unique_ptr<Serializer::ChessBoardT> UnPackSizePrefixedChessBoard(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Serializer::ChessBoardT>(GetSizePrefixedChessBoard(buf)->UnPack(res));
}

}  // namespace Serializer

#endif  // FLATBUFFERS_GENERATED_CHESS_SERIALIZER_H_
